/**
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { promisify } from 'util';
import * as path from 'path';
import { promises as fsp } from 'fs';

import glob from 'glob';

const globP = promisify(glob);

export default function () {
  let previousWorkerContent;

  return {
    name: 'image-worker-plugin',
    async buildStart() {
      const base = path.join(process.cwd(), 'src', 'features', 'worker');
      const tsImports = (
        await globP('../*/**/worker/*.ts', {
          cwd: base,
        })
      )
        .filter((tsFile) => !tsFile.endsWith('.d.ts'))
        .map((tsFile) => tsFile.slice(0, -'.ts'.length));

      const tsNames = tsImports.map((tsImport) => [
        tsImport,
        path.basename(tsImport),
      ]);

      const workerFile = [
        `// This file is autogenerated by lib/image-worker-plugin.js`,
        `import { expose } from 'comlink';`,
        `import { timed } from './util';`,
        tsNames.map(([path, name]) => `import ${name} from './${path}';`),
        `const exports = {`,
        tsNames.map(([_, name]) => [
          `  ${name}(`,
          `    ...args: Parameters<typeof ${name}>`,
          `  ): ReturnType<typeof ${name}> {`,
          `    return timed('${name}', () => ${name}(...args));`,
          `  },`,
        ]),
        `};`,
        `export type ProcessorWorkerApi = typeof exports;`,
        `expose(exports, self);`,
      ]
        .flat(Infinity)
        .join('\n');

      // If nothing's changed, avoid touching the file to avoid infinite rebuilding in watch mode
      if (previousWorkerContent === workerFile) return;
      previousWorkerContent = workerFile;

      const tsConfigReferences = tsImports.map((tsImport) => ({
        path: path.dirname(tsImport),
      }));

      const workerTsConfig = {
        extends: '../../../generic-tsconfig.json',
        compilerOptions: {
          lib: ['webworker', 'esnext'],
        },
        references: tsConfigReferences,
      };

      const bridgeTsConfig = {
        extends: '../../../../generic-tsconfig.json',
        compilerOptions: {
          lib: ['esnext', 'dom', 'dom.iterable'],
          types: [],
        },
        include: ['../../../client/lazy-app/util.ts', '**/*.ts'],
        references: tsConfigReferences.map((ref) => ({
          path: path.join('..', ref.path),
        })),
      };

      const bridgeMeta = [
        `// This file is autogenerated by lib/image-worker-plugin.js`,
        tsNames.map(([path, name]) => `import type ${name} from '../${path}';`),
        `export const methodNames = ${JSON.stringify(
          tsNames.map(([_, name]) => name),
          null,
          '  ',
        )} as const;`,
        `export interface BridgeMethods {`,
        tsNames.map(([_, name]) => [
          `  ${name}(`,
          `    signal: AbortSignal,`,
          `    ...args: Parameters<typeof ${name}>`,
          `  ): Promise<ReturnType<typeof ${name}>>;`,
        ]),
        `}`,
      ]
        .flat(Infinity)
        .join('\n');

      await Promise.all([
        fsp.writeFile(
          path.join(base, 'tsconfig.json'),
          JSON.stringify(workerTsConfig, null, '  '),
        ),
        fsp.writeFile(
          path.join(base, 'bridge', 'tsconfig.json'),
          JSON.stringify(bridgeTsConfig, null, '  '),
        ),
        fsp.writeFile(path.join(base, 'index.ts'), workerFile),
        fsp.writeFile(path.join(base, 'bridge', 'meta.ts'), bridgeMeta),
      ]);
    },
  };
}
